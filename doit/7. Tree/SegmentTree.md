## SegmentTree

주어진 데이터의 구간 질의(합, 곱, ...)와 데이터 업데이트를 빠르게 수행하기 구하기 위해 고안해낸 자료구조의 형태

- 구간 합, 최댓값, 최솟값 등을 빠르게 구한다.

부모 노드: index

왼쪽 자식 노드: index * 2

오른쪽 자식 노드: (index * 2) + 1

0. 변수명

   1. n: 원본 데이터 개수
   2. data[]: 원본 데이터
   3. k: 2ᴷ >= n 만족하는 최소 정수
   4. size: 리프 시작 인덱스, size = 2ᴷ
   5. tree[]: 트리 배열, 길이 2 * size
   6. MAX: 기본값 필요 시 사용(최솟값 트리 등)

1. Build

   1. 리프 레벨 준비

      - size = 2ᴷ

      - tree.length = 2 * size

   2. 리프 채우기

      - tree[size + i] = data[i] (i = 0 .. n-1)

      - tree[size + i] = 0 또는 MAX (i = n .. size-1)

   3. 내부 노드 채우기
      - `tree[i] = tree[i*2] + tree[i*2 + 1] (i = size-1 .. 1)`

2. Query 과정 요약

   리프 레벨부터 독립 노드를 찾아가며 연산하는 과정

   1. 리프 인덱스로 이동

      - left = left + size - 1
        right = right + size - 1

   2. 독립 노드 합산하면서 상위로 이동

      1. 현재 left가 홀수라면, left는 오른쪽 자식에 해당하며 현재 구간의 독립 노드
         이 경우 tree[left] 값을 result에 더하고, 이미 사용한 노드를 제외하기 위해 left를 하나 증가

      2. 현재 right가 짝수라면, right는 왼쪽 자식에 해당하며 현재 구간의 독립 노드
         이 경우 tree[right] 값을 result에 더하고, 이미 사용한 노드를 제외하기 위해 right를 하나 감소

      3. 현재 레벨에서 사용할 수 있는 독립 노드들을 모두 처리했으면, left와 right를 각각 2로 나누어 부모 레벨로 이동한다.

      4. 이 과정을 반복하여 left가 right보다 커지는 순간, 모든 독립 노드가 처리되었음을 의미

3. Update

   1. 변경할 데이터의 위치 idx를 세그먼트 트리의 리프 노드 위치로 이동

      idx = idx + (size - 1)

   2. 해당 리프 노드의 값을 새로운 값 value로 변경

   3. 값이 변경된 리프 노드의 부모 노드로 이동

      부모 노드는 두 자식 노드의 값을 이용해 자신의 값을 계산

   4. 현재 노드의 두 자식 노드 값을 이용해 자신의 값을 다시 계산

   5. 이 과정을 루트 노드에 도달할 때까지 반복