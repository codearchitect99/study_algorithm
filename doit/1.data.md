# 자료구조

## 배열과 리스트

배열

- 연속 공간에 값이 채워져 있는 형태의 자료구조
- 인덱스를 사용하여 값에 접근할 수 있다.
- 값을 삽입하거나 삭제하기 어렵다.
- 값을 삽입하거나 삭제하려면 해당 인덱스 주변 값을 이동시키는 과정이 필요하다.
- 배열의 크기는 한 번 선언하면 크기를 늘리거나 줄일 수 없다.

리스트

- 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
- 값에 접근하려면 Head 포인터부터 순서대로 접근해야한다.
- 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.
- 선언할 때, 크기를 별도로 지정하지 않아도 된다. -> 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
- 포인터를 지정할 공간이 필요하므로 구조가 복잡하다.

---

11720 - 숫자의 합

N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.

입력

첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.

출력

입력으로 주어진 숫자 N개의 합을 출력한다.

```java
import java.util.Scanner;
// import java.lang.Character;		// getNumericValue() 사용하지 않고 가능

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        
        int num = sc.nextInt();
        String input = sc.next();

        // doit code - char array로 변환 추가
				char[] cInput = input.toCharArray();
      
        int result = 0;

        for (int i = 0; i < num; i++) {
          	// my code
            // result += Character.getNumericValue(input.charAt(i));
          
          	// doit code
            result += cInput[i] - '0';
        }
        
        System.out.println(result);
    }
}
```

- getNumberticValue()를 사용하냐 vs char[] 배열을 이용하여 " - '0' "를 사용하냐
- char[] 배열을 이용하는 것이 더 효율적

---

1546 - 평균

세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.

예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.

세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.

입력

첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.

출력

첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        int[] grades = new int[n];

        // ----------
        // me
        // * 최댓값을 입력받으면서 구하고 각각 double 연산
        // int max = Integer.MIN_VALUE;
        // for (int i = 0; i < num; i++) {
        //     grades[i] = sc.nextInt();
        //     max = max < grades[i] ? grades[i] : max;
        // }
        //
        // double result = 0;
        // for (int i = 0; i < num; i++) {
        //     result += (double) grades[i] / max * 100.0;
        // }
        //
        // System.out.println(result/num);
        // ----------

        // doit
        // * 최댓값, 입력 동시에 작동하고 마지막에 한번에 연산
        // * 한번에 연산하기에 double 연산 필요x
        int max = 0;
        int sum = 0;
 
        for (int i = 0; i < n; i++) {
            grades[i] = sc.nextInt();
            max = (max < grades[i]) ? grades[i] : max;
            sum += grades[i];
        }

        System.out.println(sum * 100.0 / max / n);
    }
}
```

## 구간 합

 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘

합 배열 공식 S[i] = S[i - 1] + A[i]

구각 합 ex) S[5] - S[1] = A[2] + A[3] + A[4] + A[5]

---

11659 - 구간 합 구하기 4

수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.

입력

첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.

출력

총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.

제한

1 ≤ N ≤ 100,000

1 ≤ M ≤ 100,000

1 ≤ i ≤ j ≤ N

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws Exception {
        // me
        // * logic은 괜찮지만 입력 조건들을 고려하였을 때,
        // * Scanner 사용은 시간 초과 유발 가능
        // Scanner sc = new Scanner(System.in);
        //
        // int n = sc.nextInt();
        // int m = sc.nextInt();
        //
        // long[] nums = new long[n];
        // for (int i = 0; i < n; i++) {
        //     if (i == 0) nums[i] = sc.nextInt();
        //     else nums[i] = nums[i - 1] + sc.nextInt();
        // }
        //
        // for (int i = 0; i < m; i++) {
        //     int a = sc.nextInt();
        //     int b = sc.nextInt();
        //
        //     if (a > 1) System.out.println(nums[b - 1] - nums[a - 2]);
        //     else System.out.println(nums[b-1]);
        // }
        
        // doit
        // * 위 로직에서 BufferedReader, InputStreamReader, StringTokenizer 이용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        long[] nums = new long[n + 1];
        nums[0] = 0;

        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            nums[i] = nums[i - 1] + Long.parseLong(st.nextToken());

        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            sb.append(nums[b] - nums[a - 1]).append("\n");
        }
        
        System.out.println(sb);

    }
}
```

입력 값이 많을 때는 BufferedReader, InputStreamReader, StringTokenizer 이용하기

---

2018 - 수들의 합 5

어떠한 자연수 N은, 몇 개의 연속된 자연수의 합으로 나타낼 수 있다. 당신은 어떤 자연수 N(1 ≤ N ≤ 10,000,000)에 대해서, 이 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 알고 싶어한다. 이때, 사용하는 자연수는 N이하여야 한다.

예를 들어, 15를 나타내는 방법은 15, 7+8, 4+5+6, 1+2+3+4+5의 4가지가 있다. 반면에 10을 나타내는 방법은 10, 1+2+3+4의 2가지가 있다.

N을 입력받아 가지수를 출력하는 프로그램을 작성하시오.

입력

첫 줄에 정수 N이 주어진다.

출력

입력된 자연수 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 출력하시오

```java
// me
// * 결과는 나오지만 반복문 중첩으로 비효율적 -> 메모리 초과
// * 투 포인터로 해결해보기
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        long[] nums = new long[n + 1];
        nums[0] = 0;

        int length = (n+1)/2; 

        for (int i = 1; i <= length; i++) {
            nums[i] = nums[i - 1] + i;
        }
        
        int result = 1;
        for (int i = 1; i < length; i++) {
            for (int j = i + 1; j <= length; j++) {
                if (nums[j] - nums[i-1] == n) {
                    result++;
                    break;
                }
            }
        }
        System.out.println(result);
    }
}
```

```java
// doit
// * 투 포인터 활용
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);

        long n = sc.nextLong();
        
        long start = 1;
        long end = 1;
        long sum = 1;
        int result = 0;
        
        while (start <= n) {
            if (sum < n) {
                end++;
                if (end > n) break;	// 없어도 되지만 있으면 훨씬 더 효율적
                sum += end;
            }
            else if (sum == n) {
                result++;
                sum -= start;
                start++;
            }
            else if (sum > n) {
                sum -= start;
                start++;
            }
        }
        System.out.println(result);
    }
}
```

기존 코드는 중첩 반복문을 써서 시간복잡도 N^2이 나오지만 투 포인터를 활용하면 시간복잡도 N -> 훨씬 효율적

