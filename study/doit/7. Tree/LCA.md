## LCA

Lowest Common Ancestor 최소 공통 조상

임의의 두 노드를 각각 거슬러 올라가면서 처음 공통으로 만나게 되는 부모 노드

- 부모를 하나씩 올리는 방식

  - 시간 복잡도: O(N)

  1. 각 노드의 부모 정보를 p[node], 각 노드의 깊이를 depth[node]에 저장
     - DFS or BFS를 이용하여 깊이 탐색

  2. 먼저 두 노드 a, b의 깊이를 비교

     - depth[a] > depth[b]이면 a = p[a]로 한 칸씩 올리고,
       반대로 depth[b] > depth[a]이면 b = p[b]로 한 칸씩 올린다.

     - 이 과정을 반복하여 depth[a] == depth[b]로 맞춘다.

  3. 깊이가 같아진 뒤 a != b인 동안 a = p[a], b = p[b]를 동시에 수행한다.
  4. 두 노드가 처음으로 같아지는 지점이 LCA

- Binary Lifting 방식

  - 시간복잡도: O(log N)
  - 점화식: `P[k][n] = P[k - 1][P[k - 1][n]]`

  1. 각 노드의 2ᴷ번째 부모를 `P[k][node]`에 미리 저장

     - ex) `P[0][node]`: 바로 위 부모, `P[2][node]`: 4칸 위 부모
     - DFS or BFS를 이용하여 부모 노드 값 저장
       1. `P[0][idx]`: 각 노드의 부모 노드 값 저장
       2. 점화식을 이용하여 값 저장
          - `P[1][n] = P[0][P[0][n]]`

  2. LCA 질의 시, 먼저 depth[a]와 depth[b]의 차이를 계산

  3. 깊이 차이를 이진수로 분해하여 한 번에 점프해 깊이를 맞춘다.

     - 이 때 a와 b는 같은 레벨, 서로 다른 가지에 있는 노드

  4. k = 0이 될 때까지 반복

     - `P[0][a] = P[0][b]`이 되는 값이 LCA
     - ex} depth = 5 이면 k = 2 (2² <= 5)

     1. `P[2][a]`와 `P[2][b]` 비교
        1. 두 값이 같으면 LCA는 4번째 위 또는 아래에 있다는 것
           1. k 값을 1 줄여서 이동하기
        2. 두 값이 다르면 LCA는 더 위에 있다는 것
           그 자리로 서로 점프 이동

